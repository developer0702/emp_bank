---
name: Helm Upgrade and Install
description: Template to handle the K8S context setup and Helm Install
inputs:
  kube-context:
    description: The PRM K8S context file used to set up the runner's local k8s context
      for interaction with the namespace
    required: true
  datacenter:
    description: "The targeted datacenter, expects 'elr' or 'ctc'"
    required: true
  k8s-namespace:
    description: The HCC K8S Namespace
    required: true
  release-name:
    description: Release name of the service
    required: false
  image-tag:
    description: Docker Image tag to pull and deploy
    required: true
  chart-version:
    description: Helm chart version to pull and deploy
    required: true
  artifactory-url:
    description: Artifactory Repo URL housing the helm packages
    required: true
  registry-token:
    description: Token for Artifactory access
    required: true
  vault-role-id:
    description: The vault role ID for hashicorp vault
    required: true
  vault-secret-id:
    description: The secret ID for hashicorp vault
    required: true
  target-env:
    description: The target environment to deploy to
    required: true
runs:
  using: composite
  steps:
  - name: checkout out repository code
    uses: actions/checkout@v4
  - name: Set Kubernetes Context
    uses: azure/k8s-set-context@v4
    with:
      method: kubeconfig
      kubeconfig: "${{ inputs.kube-context }}"
  - name: Helm tool installer
    uses: Azure/setup-helm@v4
    with:
      version: v3.8.2
  - name: Update key
    shell: bash
    run: (type -p wget >/dev/null || (sudo apt update && sudo apt-get install wget -y)) && sudo mkdir -p -m 755 /etc/apt/keyrings && wget -qO- https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg > /dev/null && sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg && echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null && sudo apt update && sudo apt install gh -y
  - name: Install jq
    shell: bash
    run: sudo apt-get update && sudo apt-get install -y jq
  - name: Download HCC API Gateway public certificate (for mTLS)
    id: download-api-gateway-cert
    shell: bash
    run: |
      SECRET_EXISTS=$(kubectl get secret hcp-gw-trusted-ca-secret -n ${{ inputs.k8s-namespace }} >/dev/null 2>&1 && echo "true" || echo "false")

      if [[ $SECRET_EXISTS == "false" ]]; then
        mkdir -p /tmp/api-gateway
        if [[ "${{ env.prod_deploy}}" == "true" ]]; then
          curl -o /tmp/api-gateway/cert.pem \
            https://repo1.uhc.com/artifactory/generic-local/com/optum/stargate/certs/hcp/api.uhg.com.pem
        else
          curl -o /tmp/api-gateway/cert.pem \
            https://repo1.uhc.com/artifactory/generic-local/com/optum/stargate/certs/hcp/api-stg.uhg.com.pem
        fi
        if test -f /tmp/api-gateway/cert.pem; then
          echo "install_certificate=true" >> $GITHUB_OUTPUT
        else
          echo "install_certificate=false" >> $GITHUB_OUTPUT
        fi
      else
        echo "install_certificate=false" >> $GITHUB_OUTPUT
      fi
  - name: Create k8 secret for API Gateway certificate (for mTLS)
    if: steps.download-api-gateway-cert.outputs.install_certificate == 'true'
    shell: bash
    run: |
      kubectl create secret generic hcp-gw-trusted-ca-secret \
        -n ${{ inputs.k8s-namespace }} \
        --save-config \
        --dry-run=client \
        --from-file=ca.crt=/tmp/api-gateway/cert.pem \
        -o yaml | \
        kubectl apply -n ${{ inputs.k8s-namespace }} -f -
  - name: Pull Helm chart
    shell: bash
    run: |
      echo "Pulling Helm Chart from ${{ inputs.artifactory-url }}"
      curl -H "X-JFrog-Art-Api:${{ inputs.registry-token }}" -O https://repo1.uhc.com/artifactory/helm-local/optum-ob-core-helm/ob-core-contribution-helm/ob-core-contribution-api-${{ inputs.chart-version }}.tgz

      mkdir helm-chart
      tar zxvf ./${{ inputs.release-name }}-${{ inputs.chart-version }}.tgz -C helm-chart
  - name: Check Existing Helm Deployment Status
    id: check_helm_deployment_status
    shell: bash
    run: |
      pending_upgrades=$(helm list --filter ${{inputs.release-name}}-${{inputs.target-env}} --all | grep -E 'pending-upgrade|pending-rollback|pending-install|failed' && echo "true" || echo "false")
      if [[ $pending_upgrades == *"true"* ]]; then
        echo "Pending upgrades found."
        deployments=$(helm list --filter ${{inputs.release-name}}-${{inputs.target-env}} --all | grep -E 'pending-upgrade|pending-rollback|pending-install|failed')
        echo "has_pending_upgrades=true" >> $GITHUB_OUTPUT
        echo "pending_upgrades=$deployments" >> $GITHUB_OUTPUT
      else
      echo "No pending upgrades found."
        echo "has_pending_upgrades=false" >> $GITHUB_OUTPUT
      fi
  - name: Rollback deployments
    id: rollback_deployments
    if: steps.check_helm_deployment_status.outputs.has_pending_upgrades == 'true'
    shell: bash
    run: |
      deployments="${{ steps.check_helm_deployment_status.outputs.pending_upgrades }}"
      if [ -n "$deployments" ]; then
        while IFS= read -r upgrade; do
          deployment_name=$(echo "$upgrade" | awk '{print $1}')
          previous_revision=$(($(echo "$upgrade" | awk '{print $3}')-1))
          helm rollback "$deployment_name" "$previous_revision"
        done <<< "$deployments"
      else
        echo "No deployments in pending-upgrade/pending-rollback/pending-install/failed state. Skipping rollback."
      fi
  - name: Deploy application to Target Env K8s
    id: deploy_to_target_env
    shell: bash
    run: |
      helm --debug upgrade --install --atomic --wait --timeout 300s ${{inputs.release-name}}-${{inputs.target-env}} \
        "helm-chart/${{ inputs.release-name }}/" -n ${{ inputs.k8s-namespace }} $valuesYAML \
        --set-string image.tag=$imageTag,release.name=${{inputs.release-name}},vault.role.id=${{ inputs.vault-role-id }},vault.secret.id=${{ inputs.vault-secret-id }},app.ingress.datacenter=${{ inputs.datacenter }} \
        || echo "::set-output name=deployment-failed::true"
    env:
      valuesYAML: "-f helm-chart/${{inputs.release-name}}/charts/ob-core-common-helm/values.yaml\
        \  -f helm-chart/${{inputs.release-name}}/values/${{inputs.target-env}}.yaml"
      imageTag: "${{ inputs.image-tag }}"
  - name: Get pod logs on error
    if: steps.deploy_to_target_env.outputs.deployment-failed == 'true'
    shell: bash
    run: |
      POD_NAME=$(kubectl get pods --sort-by=.metadata.creationTimestamp -n ${{ inputs.k8s-namespace }} -l app=${{inputs.release-name}}-${{inputs.target-env}} | tail -1 | awk '{print $1}')
      POD_LOGS=$(kubectl logs -p $POD_NAME -n ${{ inputs.k8s-namespace }})
      if [ "$(echo "$POD_LOGS" | grep -o "." | head -n 1)" = "{" ]; then   echo "$POD_LOGS" | jq -r '"\(.timestamp // "") \(.level // "") [\(.thread // "")] \(.logger // ""): \(.message // "") \(.context // "") \(.exception // "")"'; else   echo "$POD_LOGS"; fi
      helm rollback ${{inputs.release-name}}-${{inputs.target-env}} --recreate-pods -n ${{ inputs.k8s-namespace }}
      exit 1
